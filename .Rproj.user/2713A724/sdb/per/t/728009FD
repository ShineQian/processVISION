{
    "contents" : "#' Process a VISION XML file from their EDC\n#' @name processVISION\n#' @aliases processVISION\n#' @description This function takes in a XML and creates a list of \n#' R data.frames\n#' @param xml XML filename from VISION EDC, or if \\code{\\link{xmlParse}} \n#' has already been run, then the XML document with class \n#' \\code{XMLAbstractDocument}.  \n#' if (\\code{isXML = FALSE}), should have \".xml\" extension\n#' not \".zip\". \n#' @param isXML (logical) indicating whether \\code{xml} is an \n#' \\code{XMLAbstractDocument} class (TRUE), or a filename (default FALSE)\n#'  \n#' @param drop.dsets vector of dataset names that can be dropped (NULL)\n#' @param dset.names vector of dataset names to match (after dropping drop.dsets) \n#' if these do not match EXACTLY (case) the dataset names (all of them), \n#' this will error(NULL)\n#' @param drop.pattern vector of regular expression that will drop datasets \n#' that contain patterns using \\link{grep}\n#' @param keep.pattern vector of regular expression that will keep only datasets \n#' that contain any of the patterns \\link{grep}\n#'   \n#' @param verbose logical - Progress printed?(TRUE)\n#' @export\n#' @examples\n#' \\dontrun{\n#' }\n#' @seealso \\code{\\link{xmlParse}}, \\code{\\link{xmlRoot}}\n#' @return A list with slots df.list, the list of datasets, \n#' datetime, the date/time the data was exported according to the XML,\n#' dsets, the dataset names, should match names(df.list).\n\nprocessVISION <- function(xmlfile, \n                          isXML=FALSE,\n                          drop.dsets = NULL, \n                          dset.names = NULL, \n                          verbose=TRUE,\n                          drop.pattern = NULL,\n                          keep.pattern = NULL,\n                          drop.new=TRUE){\n\n  run <- get.dnames(xmlfile, isXML=isXML, names.only=FALSE)\n  dsets <- run$dsets\n  proc <- run$proc\n  run <- NULL\n  \n  ### get the list of all data sets\n  ldsets <- sort(unique(tolower(dsets)))\n  \n  ### dsets is the datasets to run\n  if (!is.null(drop.dsets)) dsets <- dsets[ !(dsets %in% drop.dsets) ]\n\n  ### drop pattern\n  if (!is.null(drop.pattern)) {\n    dset.mat = sapply(drop.pattern, grepl, x=dsets)\n    dset.drop = apply(dset.mat, 1, any)\n    dsets <- dsets[ !dset.drop ]\n  }\n  \n  ### keep pattern\n  if (!is.null(keep.pattern)) {\n    dset.mat = sapply(keep.pattern, grepl, x=dsets)\n    dset.keep = apply(dset.mat, 1, any)\n    dsets <- dsets[ dset.keep ]\n  }\n    \n  ndsets <- length(dsets)\n  \n  sd.1 <- setdiff(dsets, dset.names)\n  sd.2 <- setdiff(dset.names, dsets)\n  \n  if (length(sd.1) > 0 & !is.null(dset.names)){\n    print(sd.1)\n    stop(\"These are datasets in the xml, but not the check names\")\n  }\n  if (length(sd.2) > 0){\n    print(sd.2)\n    stop(\"These are datasets in the checknames, but not the xml\")\n  }  \n  \n  df.list <- vector(mode=\"list\", length=ndsets)\n  names(df.list) <- dsets\n  \n  ### loop through, converting every dataset to a data.frame.\n  for (idset in 1:ndsets){\n    dname <- dsets[idset]\n    if (verbose) print(dname)\n    dset <- paste0(\"//\", dname)\n    \n    #### get the records for that form\n    nodeset <- getNodeSet(proc, dset)\n    \n    ### convert to data.frame\n    dataset <- xmlToDataFrame(doc=proc, nodes=nodeset)\n    \n    ### replace any empty strings with NA\n    spaces <- sapply(dataset, function(x) x %in% \"\")\n    dataset[spaces] <- NA\n    \n    if (drop.new) {\n      dataset <- dataset[ !(dataset$formState %in% \"New\"), ]\n    }\n    \n    df.list[[dname]] <- dataset\n  }  \n  \n  \n  ### get date/time from the export from the XML\n  dt <- xpathApply(proc, \"//export_from_vision_EDC\", \n                   xmlGetAttr, \"date\")[[1]]\n  ss <- strsplit(dt, \" \")[[1]]\n  datetime <- paste(ss[1:2], collapse=\"_\")\n  datetime <- gsub(\":\", \"\", datetime)\n  \n  return(list(df.list=df.list, datetime=datetime, dsets=dsets))\n  \n}\n\n\n\n#' Process a VISION XML file from their EDC\n#' @name get.dsets\n#' @aliases get.dsets\n#' @description Gets the dataset names from an VISION XML document\n#' @param xml XML filename from VISION EDC, or if \\code{\\link{xmlParse}} \n#' has already been run, then the XML document with class \n#' \\code{XMLAbstractDocument}.  \n#' if (\\code{isXML = FALSE}), should have \".xml\" extension\n#' not \".zip\". \n#' @param isXML (logical) indicating whether \\code{xml} is an \n#' \\code{XMLAbstractDocument} class (TRUE), or a filename (default FALSE)\n#' @param names.only (logical) return only the dataset names, (default TRUE)\n#' @export\n#' @examples\n#' \\dontrun{\n#' }\n#' @seealso \\code{\\link{xmlParse}}, \\code{\\link{xmlRoot}}\n#' @return A list with slots dsets, the dataset names, and if \n#' \\code{names.only = FALSE}, proc, the XML parsed object.\n\nget.dnames <- function(xml, isXML=FALSE, names.only=TRUE){\n## parse the xml  \n  if (isXML){\n    ### make sure an XML document\n    stopifnot(inherits(proc, \"XMLAbstractDocument\"))\n    proc <- xml\n  } else {\n    proc <- xmlParse(xml)\n  }\n  ### get datasets name\n  xroot <- xmlRoot(proc)\n  n <- names(xroot)\n  dsets <- unique(n)\n  if (names.only){\n    proc <- NULL\n  }\n  return(list(dsets=dsets, proc=proc))\n}",
    "created" : 1389124662129.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "612861302",
    "id" : "728009FD",
    "lastKnownWriteTime" : 1389124695,
    "path" : "~/Dropbox/CTR/DHanley/XML_Processing/processVISION/R/processVISION.R",
    "project_path" : "R/processVISION.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}